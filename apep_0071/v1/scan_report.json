{
  "paper_id": "apep_0071",
  "scan_date": "2026-02-06T12:40:32.708568+00:00",
  "scan_version": "2.0.0",
  "model": "openai/gpt-5.2",
  "overall_verdict": "SUSPICIOUS",
  "files_scanned": 11,
  "flags": [
    {
      "category": "DATA_PROVENANCE_MISSING",
      "severity": "MEDIUM",
      "file": "01_fetch_data.R",
      "lines": [
        86,
        129
      ],
      "evidence": "Treatment assignment (adoption_year/entry_force_date/treated) is manually encoded rather than programmatically fetched from a verifiable source or accompanied by a machine-readable citation artifact (e.g., a downloaded crosswalk, URLs, or archived JSON/CSV). The manuscript describes treatment timing and mentions sources, but the replication pipeline cannot independently verify that these dates/codings match those sources without additional documentation or a fetch script. This is not necessarily misconduct, but it is a provenance/reproducibility gap for a key causal variable.: canton_treatment <- tribble(\n  ~canton_id, ~canton_abbr, ~adoption_year, ~entry_force_date, ~treated,\n  # Treated (energy law in force before May 2017)\n  18, \"GR\", 2010, \"2011-01-01\", TRUE,   # Graub\u00fcnden\n  2,  \"BE\", 2011, \"2012-01-01\", TRUE,   # Bern\n  19, \"AG\", 2012, \"2013-01-01\", TRUE,   # Aargau\n  13, \"BL\", 2016, \"2016-07-01\", TRUE,   # Basel-Landschaft\n  12, \"BS\", 2016, \"2017-01-01\", TRUE,   # Basel-Stadt\n  ...\n)\n\n# Source: LexFind.ch + HuggingFace swiss_legislation",
      "confidence": 0.82
    },
    {
      "category": "DATA_PROVENANCE_MISSING",
      "severity": "HIGH",
      "file": "09_fix_rdd_sample.R",
      "lines": [
        35,
        48
      ],
      "evidence": "The script depends on an RDS file (\"gemeinde_spatial.rds\") that is not created by 01_fetch_data.R (which saves \"voting_sf.rds\", \"gemeinde_boundaries.rds\", etc.). This breaks provenance: it is unclear how \"gemeinde_spatial.rds\" was produced, from what raw source, and whether it corresponds to the same 2017 municipal geometry used elsewhere. Because this file underpins the 'corrected sample construction' that the manuscript emphasizes as crucial, the missing/unclear upstream creation is a serious integrity/reproducibility concern.: gemeinde_sf <- readRDS(file.path(data_dir, \"gemeinde_spatial.rds\"))",
      "confidence": 0.9
    },
    {
      "category": "METHODOLOGY_MISMATCH",
      "severity": "MEDIUM",
      "file": "07_expanded_analysis.R",
      "lines": [
        93,
        163
      ],
      "evidence": "The manuscript\u2019s primary/cleanest RDD is described as using 'corrected sample construction' where the running variable is 'distance to each municipality's own canton border' and restricting to municipalities in cantons that directly share a treated-control border, plus a same-language (German\u2013German border) restriction. In this script, distance is computed to a pooled 'policy border' geometry (union of treated-control shared borders), then signed by treated status. That does not implement 'distance to each municipality\u2019s own canton border' as stated in the paper. Additionally, the 'same-language borders' restriction is implemented as filtering municipalities with canton-level lang == 'German', which does not ensure the relevant border segment is German\u2013German (it could still include municipalities near borders to French/Italian cantons if the pooled border geometry includes such segments). This mismatch is mitigated if the paper\u2019s main results come from the corrected-sample scripts (09_fix_rdd_sample.R / 10_placebo_corrected.R), but this file as-written would not reproduce the manuscript\u2019s stated primary RDD exactly.: border <- get_policy_border(canton_borders, treated_canton_ids, canton_id_col = \"canton_id\")\n\nvoting_sf_clean <- voting_sf_clean %>%\n  mutate(\n    dist_to_border = as.numeric(st_distance(centroid, border)) / 1000,  # km\n    distance_to_border = ifelse(treated, dist_to_border, -dist_to_border)\n  )\n...\n# Specification 2: Same-language borders only (German-German borders)\nsame_lang_sample <- rdd_sample %>%\n  filter(lang == \"German\")",
      "confidence": 0.77
    },
    {
      "category": "SUSPICIOUS_TRANSFORMS",
      "severity": "LOW",
      "file": "01_fetch_data.R",
      "lines": [
        228,
        246
      ],
      "evidence": "The logic for 'border_with_treated' appears incorrect/fragile: `any(nc %in% treated_ids) != treated` compares a boolean about whether any neighbor is treated to the municipality's treated status; this does not directly test whether there exists a neighbor in the opposite treatment state (it can misclassify cases with multiple neighbors, treated-treated adjacency, or missing treatment coding). If this indicator is used downstream to restrict samples, it could create unintended inclusion/exclusion around borders. Severity is LOW because other scripts appear to construct the corrected RDD sample more explicitly, and this object is only saved as an intermediate RDS here.: border_gemeinden <- voting_sf %>%\n  mutate(\n    neighbor_cantons = map(row_number(), function(i) {\n      unique(voting_sf$canton_id[neighbors[[i]]])\n    }),\n    is_border = map_lgl(neighbor_cantons, function(nc) {\n      any(nc != canton_id)\n    }),\n    border_with_treated = map_lgl(neighbor_cantons, function(nc) {\n      # This gemeinde is control, neighbor is treated (or vice versa)\n      any(nc %in% c(2, 12, 13, 18, 19)) != treated\n    })\n  )",
      "confidence": 0.7
    },
    {
      "category": "HARD_CODED_RESULTS",
      "severity": "LOW",
      "file": "00_packages.R",
      "lines": [
        38,
        41
      ],
      "evidence": "A global seed is set for reproducibility. This is generally good practice; however, given the manuscript\u2019s emphasis on using official referendum data, auditors often check that no stochastic data-generation step depends on the seed. In the current codebase, randomization inference/permutation steps legitimately use randomness, so this is not inherently suspicious. Logged here only as a potential audit point.: set.seed(20260127)",
      "confidence": 0.55
    }
  ],
  "file_verdicts": [
    {
      "file": "01_fetch_data.R",
      "verdict": "CLEAN"
    },
    {
      "file": "06_tables.R",
      "verdict": "CLEAN"
    },
    {
      "file": "00_packages.R",
      "verdict": "CLEAN"
    },
    {
      "file": "10_placebo_corrected.R",
      "verdict": "CLEAN"
    },
    {
      "file": "04_robustness.R",
      "verdict": "CLEAN"
    },
    {
      "file": "07_expanded_analysis.R",
      "verdict": "CLEAN"
    },
    {
      "file": "09_fix_rdd_sample.R",
      "verdict": "SUSPICIOUS"
    },
    {
      "file": "02_clean_data.R",
      "verdict": "CLEAN"
    },
    {
      "file": "08_revision_fixes.R",
      "verdict": "CLEAN"
    },
    {
      "file": "03_main_analysis.R",
      "verdict": "CLEAN"
    },
    {
      "file": "05_figures.R",
      "verdict": "CLEAN"
    }
  ],
  "summary": {
    "verdict": "SUSPICIOUS",
    "counts": {
      "CRITICAL": 0,
      "HIGH": 1,
      "MEDIUM": 2,
      "LOW": 2
    },
    "one_liner": "unclear provenance",
    "executive_summary": "Paper **apep_0071** is flagged as suspicious because the analysis script **09_fix_rdd_sample.R** depends on an external RDS input, **\"gemeinde_spatial.rds\"**, that is not generated anywhere in the documented pipeline (e.g., **01_fetch_data.R** only saves outputs like **\"voting_sf.rds\"** and **\"gemeinde_boundaries.rds\"**). This missing data provenance means the results cannot be reproduced from the provided code alone, and it is unclear where **\"gemeinde_spatial.rds\"** comes from or how it was constructed.",
    "top_issues": [
      {
        "category": "DATA_PROVENANCE_MISSING",
        "severity": "HIGH",
        "short": "The script depends on an RDS file (\"gemeinde_spatial.rds\"...",
        "file": "09_fix_rdd_sample.R",
        "lines": [
          35,
          48
        ],
        "github_url": "/apep_0071/code/09_fix_rdd_sample.R#L35-L48"
      }
    ],
    "full_report_url": "/tournament/corpus_scanner/scans/apep_0071_scan.json"
  },
  "error": null
}